# e2

e2 Integration

## Очереди

В e2 используются встроенные очереди:

* Очередь на конвертацию (Queue4Conversion).
* Очередь на доставку (Queue4Delivery).
* Очередь на повтор (Queue4Repeat).

Очереди используются для Update-сообщений. Эти сообщения обрабатываются асинхронно.
Очереди нужны для того, чтобы обеспечить надёжность доставки отправленных сообщений.
А также они дают возможность как можно меньше блокировать систему-отправитель,
отделяя процесс отправки исходного сообщения от конвертации и доставки
системам-получателям.

### Прохождение очередей

Каждая очередь реализована с помощью одной таблицы в базе данных сервера e2.
В одной колонке такой таблицы размещается содержание сообщения (xml-поток),
остальные колонки используются для обеспечения функционала очереди.

![](documentation/e2.%20Прохождение%20очередей.svg)

### Состояния элементов очередей

![](documentation/e2.%20Состояния%20элемента%20очереди.svg)

## Взаимодействие с сервером e2

В настоящее время взаимодействие с сервером происходит через
rest-подобный api. Все обращения должны осуществляться HTTP-методом
POST, в теле сообщения должен передаваться XML.

Основным URL для взаимодействия является `/post` (или его псевдоним
`/agr`, который исчезнет в будущих версиях). Тип сообщения определяется
на основании корневого тега из XML-содержимого сообщения. Таким образом,
для любого взаимодействия с сервером e2 можно использовать единую точку
доступа.

Кроме `/post` имеется 2 специализированных URL:

* `/request`: ожидает сообщения с тегами `listRequest` и
  `elementRequest`;
* `/update`: ожидает сообщения с тегом `updateRequest`.

Эти дополнительные URL выполняют проверку, что полученный тег
соответствует точке входа. В случае несоответствия обработка прерывается
и сервис вернёт ошибку.


## Процесс конвертации сообщения


## Как обрабатывается имя системы из сообщения

## Инициализация новой конфигурации (первое приближение)

Jar-файл конфигурации лежит в определённом месте (пока не в базе). При
запуске сервера стартует бин `ConfigurationManager`. Его метод
`afterPropertiesSet()` запускает метод `updateConfiguration`, отвечающий
за инициализацию конфигурации.

Создаётся новый класс-лоадер, которому передаётся путь к jar-файлу
конфигурации. Выполняется создание нового экземпляра `Configuration4E2`.

В конце процесса новый экземпляр конфигурации заменяет старый, новые
процессы теперь будут получать его.

## Запрос данных

Запрос данных нужен для того, чтобы одна из систем могла запросить текущие
данные каких-либо сущностей у других систем. Сама запрашивающая система не должна
при этом знать, у каких систем она будет запрашивать данные, как и не должна
знать что-либо об устройстве данных в запрашиваемых системах. Запрос должен
формироваться в понятиях (метаданных) запрашивающей системы. Всё остальное
должен будет сделать сервер e2, когда получит этот запрос.

### Структура запрашивающего сообщения

Для запроса данных система формирует *запращивающее сообщение*. Такое сообщение
может содержать сразу много запросов. В каждом отдельном запросе обязательно
декларируется, какая именно сущность запрашивается (то есть, элементы какой
сущности ожидаются в качестве результата). В одном сообщении может быть как
множество запросов к разным сущностям, так и множество запросов к одной и той
же сущности (например, с разными условиями фильтрации). Результаты всех
запросов будут объединены в одном ответном сообщении.

Декларирование результирующей сущности в запросе необходимо по нескольким
причинам. Первая причина - маршрутизация. Запрашивающие сообщения
маршрутизируются по тому же принципу, что и сообщения с обновлениями. То есть
на основании системы отправителя и названий запрашиваемых сущностей. Отличие
только в том, что для запросов используется отдельная таблица маршрутов.

Основная же причина указывать запрашиваемую сущность - концептуальная. Назначением
e2 является именно обмен сущностями между системами. Поэтому естественным квантом
обмена является именно элемент сущности. Поэтому, в отличие от sql,
запросы в e2 не позволяют возвращать конкретные поля сущностей, или делать какие-либо
агрегации. И в будущем такие фунции не планируются.

Считаю, что если прикладной системе нужна аналитическая функциональность, она должна
обеспечивать её сама. В системе интеграции это не нужно, тут нужно стремиться к
простоте, ведь интеграция и так явление сложное. Если же возникнут какие-то особые
случаи, которые не могут быть покрыты имеющимся функционалом e2, наверняка их будет
не слишком много, и можно будет найти для них индивидуальное решение. Благо в том,
чтобы массовая часть интеграций была решена системным, типовым образом.

Повторю ещё раз, что целью и результатом запроса e2 является получение
запрашивающей системой сообщения, содежащего текущее состояние элементов
некоторых сущностей, по структуре это сообщение подобно сообщению с обновлением.

Структура же самих запросов не должна быть слишком мощной и сложной. Надо помнить,
что запрос должен быть сконвертирован в понятия запрашиваемых систем. Если его
структура будет слишком сложной, это приведёт к усложнению конверсий, может
чаще вызывать отказы конверсий. В кончном итоге будет отталкивать от использования
системы.

Кроме собственно запросов, в запрашивающем сообщении может присутствовать
контекстный узел. Он необходим в тех случаях, когда выражения в фильтрах
запросов содержат элементы сущностей в качестве аргументов. Сама запрашивающая
система не должна знать, какие именно атрибуты в этих элементах являются
синхронизирующими, поэтому она должна выполнить минимальную сериализацию
элемента и разместить её результат в контекстном узле. Формат данных в контекстном
узле такой же, как в сообщеннии с обновлением.

### Структура ответного сообщения 

Как уже было сказано, ответное сообщение по структуре подобно сообщению с
обновлением. Отличие в том, что в общем случае оно похоже на сразу несколько
сообщений с обновлением. Ведь в зависимости от маршрутов, могли быть запрошены
сразу несколько систем. Поэтому, в сообщении ответа на верхнем уровне будут
узлы, соответствующие ответившим системам, а уже внутри каждого такого узла
будет сообщение обновления, содержащее результат запроса к соответствующей
системе.

Вместо сообщений обновления внутри узлов запрошенных систем могут оказаться узлы
ошибок, если что-то пошло не так при попытке обработать запрос. Иногда может
оказаться, что запрос какой-то сущности не удаётся сконвертировать (то есть,
ошибка возникает уже на этапе конвертации запроса, ещё до отправки в запрашиваемую
систему). Это может произойти в силу больших различий в метаданных двух систем,
либо если не хватает нужных конверсий. Это ещё один вид ошибки, который может
прийти в ответном сообщении.

### Процесс прохождения запрашивающего сообщения

Одно запрашивающее сообщение может быть направлено в несколько систем, при этом
часть сущностей пойдут в одни системы, часть в другие, а некоторые одновременно
в несколько. При этом происходит конвертация запросов в понятия запрашиваемых
систем специальными конверсиями для запросов.

Конвертация ответов осуществляется обычнми конверсиями. Маршрутизация при этом
никакая не применяется.

### Запросы. Выражения в запросах

В каждом запросе указывается ровно одна результирующая сущность.

В запросе может быть перечислено несколько условий фильтрации. По ним будет
сделана конъюнкция. В условиях фильтрации используется определённый ограниченный
набор логических выражений.

В качестве аргументов логических выражениях могут выступать скаляры, элементы сущностей, а также
пути к полям результирующей сущности. Пути могут оканчиваться как скалярным,
так и ссылочным полем сущности.

Если в выражении запроса фигурирует элемент сущности, он должен быть сериализован
в контекстном узле сообщения-запроса. При конвертации сообщения-запроса необходимо
выполнить также конвертацию элементов из контекста (по мере надобности) конверсиями
для элементов сущностей. Тогда отвечающая система сможет построить запрос, ей хватит
для этого данных. В соответствии с этим, контекст конвертации запросов должен при
необходимости включать контекст конвертации для контекста.

Допустимые логические выражения

|Выражение|Варианты аргументов                    |ref|
|---------|---------------------------------------|---|
|isNull   |(pathRef) (pathValue)                  | + |
|equals   |(pathRef, ref) (pathValue, value)      | + |
|lt       |(pathValue, value)                     |   |
|lte      |(pathValue, value)                     |   |
|gt       |(pathValue, value)                     |   |
|gte      |(pathValue, value)                     |   |
|in       |(pathRef, ref...) (pathValue, value...)| + |
|like     |(pathValue, pattern [, symbol])        |   |

## Конвертация элементов сущностей

Сериализованные данные элементов сущностей встречаются в сообщениях-обновления,
а также в контекстных узлах сообщений-запросов. В данном разделе пойдёт речь
о конвертации таких данных.

### Жизненный цикл объектов, задейстованных в конвертации

Объект класса Conversions инстанциируется для каждого сконвертированного (выходного)
сообщения. Он живёт до окончания конвертации одного сообщения. Его задача инстанциировать
и возвращать объекты для конверсии указанной сущности. Полученные конверсии также
живут до окончания конвертации данного сообщения, поэтому в их
состоянии можно кэшировать данные в приминении к текущему обрабатываемому сообщению.


## Тезаурус

*Сообщение-обновление* --- сообщение, которое отправляет конечная система,
чтобы уведомить остальные системы о произошедших в ней изменениях с момента
предыдущей выгрузки. Содержит сериализованное состояние всех сущностей, по
которым были зарегистрированы изменения, а также все сущности, на которые
привели ссылки (в том числе и транзитивные) в соответствии с моделью данных
системы. Система отправитель при этом не обязана знать, какие именно системы
будут получателями.

*Сообщение-запрос* --- сообщение, которое отправляет система, чтобы запросить
у других систем какие-либо данные. Какие именно системы будут запрошены
система-отправитель знать не обязана (но какие системы ей ответят, она сможет
узнать из ответного сообщения). Сообщение может содержать множество
запросов, сформулированных в терминах (метаданных) запрашивающей системы,
а также, в случае необходимости, узел, содержащий контекст --- сериализованные
элементы сущностей, ссылки на которые используются в качестве аргуменов
в запросах.

*Конвертация* --- сложный процесс преобразования сообщения (или части сообщения)
из понятий одной системы в понятия другой системы. Состоит из иерархического
применения *конверсий* к конвертируемым элементам исходного сообщения.

*Конверсия* --- класс, реализующий логику преобразования состояния элемента
определённой сущности из понятий одной системы в понятия другой системы.
Чаще всего, на выходе конверсии будет одна сущность в понятиях
системы-получателя, но может быть и несколько сущностей, или ни одной
(отбрасывание) элемента. Результатом может быть и просто скалярное значение.

*Конверсия запроса* --- класс, реализующий логику преобразования запроса
для определённой сущности из *сообщения-запроса* в понятия запрашиваемой
системы. Если в сообщении-запросе есть контекст, *конверсия запроса* может
вызывать *конверсию* элементов по мере необходимости.